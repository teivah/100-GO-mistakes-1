## 3.8 无法正确复制切片

`copy` 内置函数允许将元素从一个源切片复制到目标切片。 尽管它是一个方便的内置函数，但 Go 开发人员有时会误解它。 让我们看看一个导致复制错误数量的元素的常见错误。

在下面的示例中，我们将创建一个切片并将其元素复制到另一个切片。 这段代码的输出应该是什么？

```go
src := []int{0, 1, 2}
var dst []int
copy(dst, src)
fmt.Println(dst)
```

如果我们运行这个例子，它将打印 `[]`，而不是 `[0 1 2]`。 那么我们错过了什么？

为了有效地使用 `copy`，必须了解复制到目标切片的元素数量对应于以下之间的最小值：

* 源切片的长度
* 目标切片的长度

在前面的示例中，`src` 是一个 3 长度的切片，但 `dst` 是一个 0 长度的切片，因为它被初始化为零值。 因此，`copy` 将复制 3 到 0 个元素之间的最小值：0。结果切片为空。

如果我们想要执行完整的复制，目标切片的长度必须大于或等于源切片的长度。 在这里，我们将根据源切片设置一个长度：

```go
src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)
```

由于 `dst` 现在是一个长度为 3 的切片，它将复制三个元素。 这一次，如果我们运行这段代码，它将打印 `[0 1 2]`。

> **Note** 另一个常见的错误是在调用 `copy` 时颠倒了参数的顺序。 请记住，目标是前一个参数，而源是后者。

我们还要提一下，使用 `copy` 内置函数并不是复制切片元素的唯一方法。 有不同的选择，最著名的可能是以下使用 `append` 的方法：

```go
src := []int{0, 1, 2}
dst := append([]int(nil), src...)
```

我们将源切片中的元素附加到零切片。 因此，此代码创建了一个长度为 3、容量为 3 的切片副本。 这种替代方案的优点是可以在单行中完成。 然而，使用 `copy` 更惯用，因此更容易理解，即使它需要额外的一行。

将元素从一个切片复制到另一个切片是相当频繁的操作。 使用 `copy` 时，我们必须记住，复制到目标的元素数量对应于两个切片长度之间的最小值。 另外，请记住，存在复制切片的其他替代方案，因此如果我们在代码库中找到它们，我们不应该感到惊讶。

让我们继续讨论使用 `append` 时常见错误的 slice。