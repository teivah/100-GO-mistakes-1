## 2.4 过度使用 getters 和 setters

在编程中，数据封装是指隐藏对象的值或状态。`getter` 和 `setter` 是通过在未导出的对象字段之上提供导出方法来启用封装的方法。

在 Go 中，没有自动支持，正如我们在某些语言中看到的那样。使用 `getter` 和 `setter` 访问 `struct` 字段既不被认为是强制性的，也不被认为是惯用的。例如，标准库实现了一些字段可以直接访问的结构，例如 `time.Timer` 结构：

```go
timer := time.NewTimer(time.Second)
<-timer.C
```

虽然不推荐，但我们甚至可以直接修改 `C`（但我们不会再接收事件了）。然而，这个例子表明，即使我们不应该修改字段，标准库也不强制使用 `getter` 和/或 `setter`。

另一方面，使用 `getter` 和 `setter` 具有一些优势，包括：

* 它封装了与获取或设置字段相关的行为，允许以后添加新功能。例如：验证字段、返回计算值或将对字段的访问封装在互斥体周围。
* 它隐藏了内部表示，使我们在公开内容方面具有更大的灵活性。
* 它提供了在运行时属性更改时的调试拦截点，使调试更容易。

如果我们在保证前向兼容性的同时陷入这些情况或者预见到一个可能的用例，那么使用 `getter` 和 `setter` 可以带来一些价值。如果我们确实使用它们，给定一个名为 `balance` 的字段如下命名约定：
* getter 方法应该命名为 `Balance`（不是 `GetBalance`）
* setter 方法应该命名为 `SetBalance`

```go
currentBalance := customer.Balance()
if currentBalance < 0 {
        customer.SetBalance(0)
}
```

总而言之，如果结构体上的 `getter` 和 `setter` 方法没有带来任何价值，我们不应该 让我们的代码不堪重负。我们应该务实，努力在效率和遵循其他编程范式中有时被认为无可争辩的习语之间找到适当的平衡。请记住，Go 是一种独特的语言，专为许多特性而设计，包括简单性。但是，如果我们发现需要 `getter` 和 `setter`，或者在保证向前兼容性的同时预见未来的需求，那么使用它们并没有错。

下一节将讨论过度使用接口的问题。